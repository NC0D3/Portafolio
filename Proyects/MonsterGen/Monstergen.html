<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Monster Skeleton – Isometric (WebGL2)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #f0f0f0; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="glcanvas"></canvas>

  <script type="module">
  // ----------- 1) Crear contexto WebGL2 -----------
  const canvas = document.getElementById('glcanvas');
  const gl = canvas.getContext('webgl2');
  if (!gl) {
    alert("WebGL2 no disponible en este navegador.");
    throw "WebGL2 no soportado";
  }

  // Ajustar tamaño inicial + viewport
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Fondo blanco
  gl.clearColor(1.0, 1.0, 1.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // ----------- 2) Shaders mínimo -----------
  const vertexSrc = `#version 300 es
  in vec3 a_position;
  uniform mat4 u_matrix;
  void main() {
    // Cada vértice es transformado por la matriz isométrica (u_matrix)
    vec4 isoPos = u_matrix * vec4(a_position, 1.0);
    gl_Position = vec4(isoPos.xy, 0.0, 1.0);
  }`;

  const fragmentSrc = `#version 300 es
  precision highp float;
  out vec4 outColor;
  void main() {
    // Color negro sólido para las líneas
    outColor = vec4(0.1, 0.1, 0.1, 1.0);
  }`;

  function createShader(type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error("Error compilando shader:", gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function createProgram(vsSource, fsSource) {
    const vs = createShader(gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Error linkeando programa:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }
    return program;
  }

  const program = createProgram(vertexSrc, fragmentSrc);
  const posLoc   = gl.getAttribLocation(program, 'a_position');
  const matrixLoc = gl.getUniformLocation(program, 'u_matrix');

  // ----------- 3) Construir matriz isométrica en JS -----------
  // Rotaciones: 
  // - Rotar alrededor de X por -35.264° 
  // - Luego rotar alrededor de Y por 45°
  // Eso genera la típica proyección isométrica. Utilizaremos una matriz 4×4 que,
  // tras multiplicar [x,y,z,1], entregue las coordenadas finales en clip‐space XY.

  const toRad = deg => deg * Math.PI / 180;
  const α = toRad(35.264), β = toRad(45);

  const sinA = Math.sin(-α), cosA = Math.cos(-α);
  const sinB = Math.sin(β),  cosB = Math.cos(β);

  // Rx(-α)
  // [ 1,   0,     0,   0 ]
  // [ 0, cosA,  sinA,  0 ]
  // [ 0, -sinA, cosA,  0 ]
  const Rx = [
    1,    0,     0,   0,
    0,  cosA,  sinA,  0,
    0, -sinA,  cosA,  0,
    0,    0,     0,   1
  ];

  // Ry(β)
  // [ cosB, 0, sinB, 0 ]
  // [   0,  1,  0,   0 ]
  // [-sinB, 0, cosB, 0 ]
  const Ry = [
     cosB, 0, sinB, 0,
       0,  1,  0,   0,
    -sinB, 0, cosB, 0,
       0,  0,  0,   1
  ];

  // Funciones para multiplicar dos matrices 4×4 en arreglo plano Float32Array
  function mulMat4(a, b) {
    const r = new Float32Array(16);
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        let sum = 0;
        for (let k = 0; k < 4; k++) {
          sum += a[k * 4 + i] * b[j * 4 + k];
        }
        r[j * 4 + i] = sum;
      }
    }
    return r;
  }

  // Primero R = Ry * Rx
  const matRx = new Float32Array(Rx);
  const matRy = new Float32Array(Ry);
  const R_iso = mulMat4(matRy, matRx);

  // Escala uniformemente para ajustar a clip‐space
  // Ajusta este valor si tu esqueleto se sale de la vista.
  const scale = 0.5;
  const S = [
    scale,   0,     0, 0,
      0,   scale,   0, 0,
      0,     0,   0,   0,
      0,     0,   0,   1
  ];
  const matrixIso = mulMat4(new Float32Array(S), R_iso);

  // ----------- 4) Cargar JSON y crear buffer de vértices -----------
  fetch('Skeleton.json')
    .then(r => r.json())
    .then(data => {
      const joints = data.joints;
      const bones  = data.bones;

      // Construir un array [x,y,z, x,y,z, ...] para cada extremo de cada hueso
      const vertices = [];
      for (let [a, b] of bones) {
        const pa = joints[a]; // [x,y,z]
        const pb = joints[b];
        vertices.push(pa[0], pa[1], pa[2]);
        vertices.push(pb[0], pb[1], pb[2]);
      }

      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );

      // ----------- 5) Dibujar en WebGL2 -----------
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      // Pasar la matriz isométrica al shader
      gl.uniformMatrix4fv(matrixIso ? matrixLoc : matrixLoc, false, matrixIso);

      // Cada par de vértices define una línea
      gl.drawArrays(gl.LINES, 0, vertices.length / 3);
    })
    .catch(err => {
      console.error("Error cargando Skeleton.json:", err);
    });
  </script>
</body>
</html>
