<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skeleton Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script type="module">
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(1, 1, 1, 1);
gl.clear(gl.COLOR_BUFFER_BIT);

// ----------- SHADERS -----------
const vsSource = `#version 300 es
in vec3 aPosition;
uniform mat4 uMatrix;
void main() {
  gl_Position = uMatrix * vec4(aPosition, 1.0);
}`;
const fsSource = `#version 300 es
precision mediump float;
uniform vec3 uColor;
out vec4 fragColor;
void main() {
  fragColor = vec4(uColor, 1.0);
}`;

function compileShader(gl, source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(shader));
  return shader;
}

const program = gl.createProgram();
gl.attachShader(program, compileShader(gl, vsSource, gl.VERTEX_SHADER));
gl.attachShader(program, compileShader(gl, fsSource, gl.FRAGMENT_SHADER));
gl.linkProgram(program);
gl.useProgram(program);

// ----------- MATRIZ ISOMÃ‰TRICA -----------
const isoAngle = Math.PI / 6; // 30 grados
const cosA = Math.cos(isoAngle);
const sinA = Math.sin(isoAngle);
const scale = 0.2;

const isoMatrix = new Float32Array([
   scale * cosA, scale * sinA, -scale * 0.5, 0,
  -scale,       scale,         scale * 0.5, 0,
   0,           0,             scale,       0,
   0,           0,             0,           1
]);

const uMatrix = gl.getUniformLocation(program, 'uMatrix');
gl.uniformMatrix4fv(uMatrix, false, isoMatrix);

const uColor = gl.getUniformLocation(program, 'uColor');

// ----------- PLANO ROJO EN XY -----------
const planeSize = 2;
const half = planeSize / 2;
const planeVertices = new Float32Array([
  -half, -half, 0,
   half, -half, 0,
   half,  half, 0,
  -half,  half, 0
]);

const planeIndices = new Uint16Array([
  0, 1, 2,
  2, 3, 0
]);

const vaoPlane = gl.createVertexArray();
gl.bindVertexArray(vaoPlane);

const planeVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO);
gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

const planeEBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeEBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

// Dibuja plano
gl.clear(gl.COLOR_BUFFER_BIT);
gl.uniform3f(uColor, 1, 0, 0); // Rojo
gl.bindVertexArray(vaoPlane);
gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

// ----------- CARGA Y DIBUJA ESQUELETO -----------
fetch("Skeleton.json")
  .then(res => res.json())
  .then(data => {
    const joints = data.joints;
    const bones = data.bones;

    const vertices = [];
    bones.forEach(([a, b]) => {
      vertices.push(...joints[a], ...joints[b]);
    });

    const skeletonVAO = gl.createVertexArray();
    gl.bindVertexArray(skeletonVAO);

    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    gl.enableVertexAttribArray(aPosition);
    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

    gl.uniform3f(uColor, 0, 0, 0); // Negro
    gl.drawArrays(gl.LINES, 0, vertices.length / 3);
  });
</script>
</body>
</html>
