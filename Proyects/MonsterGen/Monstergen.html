<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Skeleton Viewer WebGL2</title>
  <style>
    body { margin: 0; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script type="module">
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl2');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
gl.clearColor(1.0, 1.0, 1.0, 1.0);
gl.clear(gl.COLOR_BUFFER_BIT);

// ProyecciÃ³n simple del plano YZ
function getProjectionMatrix() {
  const aspect = canvas.width / canvas.height;
  return new Float32Array([
    1/aspect, 0, 0, 0,
    0, 1,     0, 0,
    0, 0,     1, 0,
    0, 0,     0, 1,
  ]);
}

// Shader
const vertexSrc = `#version 300 es
in vec3 a_position;
uniform mat4 u_matrix;
void main() {
  gl_Position = u_matrix * vec4(a_position.yz, 0.0, 1.0); // solo YZ
}`;
const fragmentSrc = `#version 300 es
precision highp float;
out vec4 outColor;
void main() {
  outColor = vec4(0.1, 0.1, 0.1, 1.0);
}`;

// Compile shaders
function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Shader compile error:", gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
  }
  return shader;
}

// Create program
function createProgram(vsSource, fsSource) {
  const vs = createShader(gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link error:", gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
  }
  return program;
}

const program = createProgram(vertexSrc, fragmentSrc);
const positionLoc = gl.getAttribLocation(program, 'a_position');
const matrixLoc = gl.getUniformLocation(program, 'u_matrix');

// Load skeleton and draw
fetch('Skeleton.json')
  .then(r => r.json())
  .then(data => {
    const joints = data.joints;
    const bones = data.bones;

    const vertices = [];
    for (const [a, b] of bones) {
      vertices.push(...joints[a]); // punto A
      vertices.push(...joints[b]); // punto B
    }

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    gl.useProgram(program);
    gl.enableVertexAttribArray(positionLoc);
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

    gl.uniformMatrix4fv(matrixLoc, false, getProjectionMatrix());

    gl.drawArrays(gl.LINES, 0, vertices.length / 3);
  });
</script>
</body>
</html>
